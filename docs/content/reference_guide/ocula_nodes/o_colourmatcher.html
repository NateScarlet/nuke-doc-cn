<!DOCTYPE html>
<html data-mc-help-system-file-name="Default.xml" data-mc-in-preview-mode="false" data-mc-path-to-help-system="../../../" data-mc-preload-images="false" data-mc-runtime-file-type="Topic" data-mc-search-type="Stem" data-mc-target-type="WebHelp2" data-mc-toc-path="Reference Guide|Ocula 3.0 Nodes" lang="en-us" xml:lang="en-us" xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
 <head>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta charset="utf-8"/>
  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <title>
   O_ColourMatcher
  </title>
  <link href="../../../skins/default/stylesheets/Slideshow.css" rel="stylesheet"/>
  <link href="../../../skins/default/stylesheets/TextEffects.css" rel="stylesheet"/>
  <link href="../../../skins/default/stylesheets/Topic.css" rel="stylesheet"/>
  <link href="../../../skins/default/stylesheets/components/styles.css" rel="stylesheet"/>
  <link href="../../../skins/default/stylesheets/components/tablet.css" rel="stylesheet"/>
  <link href="../../../skins/default/stylesheets/components/mobile.css" rel="stylesheet"/>
  <link href="../../assets/stylesheets/master_tablestyle.css" rel="stylesheet"/>
  <link href="../../assets/stylesheets/nuke_stylesheet.css" rel="stylesheet"/>
  <script src="../../../Resources/Scripts/custom.modernizr.js">
  </script>
  <script src="../../../Resources/Scripts/jquery.min.js">
  </script>
  <script src="../../../Resources/Scripts/require.min.js">
  </script>
  <script src="../../../Resources/Scripts/require.config.js">
  </script>
  <script src="../../../Resources/Scripts/foundation.min.js">
  </script>
  <script src="../../../Resources/Scripts/plugins.min.js">
  </script>
  <script src="../../../Resources/Scripts/MadCapAll.js">
  </script>
  <script src="../../assets/stylesheets/load.js">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop">
   <a href="../../../Default.html#reference_guide/ocula_nodes/o_colourmatcher.html">
    用导航打开主题
   </a>
  </p>
  <script>
   /* <![CDATA[ */
			$(document).ready(function(){ 
			$('.dropDownMiniTOCmenu:not(:has([class*="MCMiniTocBox"]))').remove();
			});
		/* ]]> */
  </script>
  <div class="nocontent">
   <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-count="3" data-mc-breadcrumbs-divider=" &gt; " data-mc-toc="True">
    <span class="MCBreadcrumbsPrefix">
     你在这里:
    </span>
   </div>
  </div>
  <h1>
   O_ColourMatcher
  </h1>
  <p style="font-weight: normal;">
   O_ColourMatcher 插件允许您将一个视图的颜色与另一个视图的颜色进行匹配。它是专门设计来处理微妙的
   <a name="kanchor165">
   </a>
   立体视图之间有时存在的颜色差异。
  </p>
  <div class="MCDropDown MCDropDown_Open dropDown">
   <span class="MCDropDownHead dropDownHead">
    <a class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage" href="javascript:void(0);">
     <img alt="Closed" class="MCDropDown_Image_Icon" data-mc-alt2="Open" height="13" src="../../../skins/default/stylesheets/Images/transparent.gif" width="16"/>
     <span class="Master_VariablesRGContent">
      输入和控制
     </span>
    </a>
   </span>
   <div class="MCDropDownBody dropDownBody">
    <table cellpadding="0" cellspacing="0" class="TableStyle-Master_TableStyle" height="141px" style="border-spacing-x: 0;border-spacing-y: 0;border-collapse: collapse;border-color: black;caption-side: top;width: 100%;mc-table-style: url('../../assets/stylesheets/master_tablestyle.css');">
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="105px"/>
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="120px"/>
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="436px"/>
     <thead>
      <tr class="TableStyle-Master_TableStyle-Head-Header1" style="height: 23px;background-color: #cac8c9;">
       <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         连接类型
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         连接名称
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-HeadD-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         函数
        </p>
       </td>
      </tr>
     </thead>
     <tbody>
      <tr class="TableStyle-Master_TableStyle-Body-Body1">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1" rowspan="2">
        <p rowspan="2">
         输入
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         面具
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         一个可选的遮罩，用于确定从哪里获取颜色分布。例如，如果你有一个剪辑显示一个人在绿色屏幕前, 您可能需要使用面具来排除绿色区域，以便插件集中精力匹配人员。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2">
       <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body2">
        <p>
         源
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyA-Column1-Body2">
        <p class="CellBody">
         一对立体图像。
        </p>
        <p class="CellBody">
         如果视差通道和遮挡掩模没有嵌入到图像中，并且您正在使用
         <b>
          3D LUT
         </b>
         或
         <b>
          本地匹配
         </b>
         模式下，应该在图像序列后使用 O_Solver 、 O_DisparityGenerator 和 O_OcclusionDetector 节点。
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <table cellpadding="0" cellspacing="0" class="TableStyle-Master_TableStyle" height="603px" style="border-spacing-x: 0;border-spacing-y: 0;border-collapse: collapse;border-color: black;caption-side: top;width: 100%;mc-table-style: url('../../assets/stylesheets/master_tablestyle.css');">
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="100px"/>
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="117px"/>
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="108px"/>
     <col class="TableStyle-Master_TableStyle-Column-Column1" width="364px"/>
     <thead>
      <tr class="TableStyle-Master_TableStyle-Head-Header1" style="height: 23px;background-color: #cac8c9;">
       <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         控制 (UI)
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         旋钮 (脚本)
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         默认值
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-HeadD-Column1-Header1" style="font-weight: bold;">
        <p class="CellHeading">
         函数
        </p>
       </td>
      </tr>
     </thead>
     <tbody>
      <tr class="TableStyle-Master_TableStyle-Body-Subheading" data-mc-pattern="6" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Subheading" colspan="4">
        <p>
         O_ColourMatcher 选项卡
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         要使用的视图
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         视图对
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         依赖于源
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
        <p>
         设置要匹配其颜色的两个视图。这些视图将被映射到左眼和右眼。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         匹配
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         MatchWhat
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         从左到右
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         设置如何匹配视图之间的颜色:
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          从左到右
         </b>
         -调整左视图的颜色以与右视图的颜色相匹配。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          从右到左
         </b>
         -调整右侧视图的颜色以与左侧的颜色相匹配。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         模式
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         匹配模式
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         基本
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
        <p>
         设置用于颜色匹配的算法:
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          基本
         </b>
         -此模式采用一个整个视图的颜色分布，并修改该颜色分布以匹配另一个视图的分布。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          3D LUT
         </b>
         -此模式从不包括的像素上的本地匹配生成全局查找表 (LUT)。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         此模式要求输入数据流中存在视差字段和遮挡遮罩。如果这些还不存在，您可以使用 O_Solver 、 O_DisparityGenerator 和 occusiondetector 插件创建它们。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          本地匹配
         </b>
         -这种模式首先分为两个图像转换成块依
         <b>
          块大小
         </b>
         控制。然后，它匹配两个视图中相应块之间的颜色分布。如果视图之间存在局部颜色差异，例如一个视图比另一个视图亮的高光，这可能会很有用。请注意，这种模式要求输入数据流中有一个视差字段。如果没有，您可以使用 O_Solver 和 O_DisparityGenerator 插件创建一个。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         如果
         <b>
          遮挡补偿
         </b>
         如果启用，此模式还需要上游的遮挡遮罩。如果不存在，您可以使用 O_OcclusionDetector 创建一个。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         导出 3D LUT
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         ExportLUT
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         N/A
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         单击将为当前帧计算的颜色变化导出为中的 3D 查找表 (LUT)
         <b>
          。Vf
         </b>
         格式。
        </p>
        <p>
         这允许您使用 Nuke 的 Vectorfield (
         <b>
          颜色
         </b>
         &gt;
         <b>
          3D LUT
         </b>
         &gt;
         <b>
          Vectorfield
         </b>
         ) 节点。此控件仅在
         <b>
          3D LUT
         </b>
         模式。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2">
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2" colspan="4">
        <p colspan="4">
         本地匹配选项
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         块大小
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         块大小
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         20
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         定义在计算颜色匹配时分割图像的正方形块的宽度和高度 (以像素为单位)。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         此控件仅在
         <b>
          本地匹配
         </b>
         模式。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         遮挡补偿
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         遮挡补偿
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         已启用
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
        <p>
         当
         <b>
          遮挡补偿
         </b>
         启用后，o _ colourmatcher 会在它已经能够匹配的附近的未合并区域中寻找相似的颜色，并使用它找到的最接近的颜色。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         这需要上游的遮挡掩模 (您可以使用 O_OcclusionDetector 创建一个)，并且仅在
         <b>
          本地匹配
         </b>
         模式。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         边缘遮挡
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         边缘闭塞
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         0.40000001
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         设置阈值，将图像边缘视为遮挡，以减少光晕和边缘闪烁。
        </p>
        <p>
         该值越高，即使在上游遮挡遮罩中没有标记图像边缘，也越被视为遮挡。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         此控件仅在
         <b>
          遮挡补偿
         </b>
         已启用。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         颜色西格玛
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         ColourSigma
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         2
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
        <p>
         设置遮挡区域颜色匹配中边缘模糊的量。
        </p>
        <p>
         减少这一点，将遮挡区域中的颜色校正限制为相似的颜色。增加该值以模糊颜色校正。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         此控件仅在
         <b>
          遮挡补偿
         </b>
         已启用。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         区域大小
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         区域大小
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         25
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         设置用于计算被遮挡像素处的颜色校正的未遮挡像素区域的大小 (以像素为单位)。
        </p>
        <p class="tip" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;TIP:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            提示:
           </span>
          </span>
         </span>
         当
         <b>
          遮挡补偿
         </b>
         启用后，O_ColourMatcher 首先找到最接近的未合并像素，然后将该距离扩展到此像素数，以拾取要使用的未合并像素。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2" colspan="4">
        <p colspan="4">
         多尺度选项
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         样本数量
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         样品
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         5
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         设置中的样本数
         <b>
          本地匹配
         </b>
         模式。
        </p>
        <p>
         使用大于 1 的值计算多个块大小之间的修正
         <b>
          块大小
         </b>
         和
         <b>
          最大块大小
         </b>
         -然后将结果混合在一起。这有助于减少错误。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         最大块大小
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         MaxBlockSize
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         100
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
        <p>
         设置在本地匹配模式下使用多个采样时要达到的最大块大小 (以像素为单位)。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         此控件仅在设置后可用
         <b>
          模式
         </b>
         到
         <b>
          本地匹配
         </b>
         和
         <b>
          样本数量
         </b>
         值大于 1。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         样本间距
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         中间型
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
        <p>
         制服
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
        <p>
         设置在中使用多个采样时要使用的采样间隔的类型
         <b>
          本地匹配
         </b>
         模式:
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          制服
         </b>
         -采样间隔保持不变。样品间隔均匀。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          有利于小块尺寸
         </b>
         -采样间隔随着块大小的增加而增加。这加重了对较小块大小的校正，从而保留了更多细节，同时仍然包括一些较大的块大小，这些块大小更容易受到视差误差的影响。
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         颜色校正类型
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         更正类型
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
        <p>
         最佳猜测
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
        <p>
         确定 O_ColourMatcher 如何将两个视图划分为方形块，并匹配相应块之间的颜色分布:
        </p>
        <p class="tip" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;TIP:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            提示:
           </span>
          </span>
         </span>
         如果你设置
         <b>
          样本数量
         </b>
         到大于 1 的值,
         <b>
          颜色校正类型
         </b>
         对多个块大小执行此操作，然后将不同块大小的结果组合在一起。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          最小校正
         </b>
         -在你得到的结果中，它会在每个点上选择最小的校正 (也就是说，最接近你的原始图像)。如果您的视差图非常差，则此选项很有用。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          最佳猜测
         </b>
         -在你得到的结果中，这将在每一点上选择最接近目标图像的校正。目标图像是通过使用视差字段将另一个视图扭曲到您试图更正的图像上来创建的。如果你有一个非常好的视差图，这个选项会很有用。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          平均校正
         </b>
         -在每个点使用颜色校正的平均值。此选项是默认选项。
        </p>
        <p class="note" data-mc-autonum='&lt;span style="color: Black;" class="mcFormatColor"&gt;NOTE:&lt;/span&gt;  '>
         <span class="autonumber">
          <span>
           <span class="mcFormatColor" style="color: Black;">
            注意:
           </span>
          </span>
         </span>
         此控件仅在设置后可用
         <b>
          模式
         </b>
         到
         <b>
          本地匹配
         </b>
         .
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body1" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1" colspan="4">
        <p colspan="4">
         遮罩选项
        </p>
       </td>
      </tr>
      <tr class="TableStyle-Master_TableStyle-Body-Body2" style="height: 15px;">
       <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body2">
        <p>
         遮罩组件
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body2">
        <p>
         MaskWith
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body2">
        <p>
         没有
        </p>
       </td>
       <td class="TableStyle-Master_TableStyle-BodyA-Column1-Body2">
        <p>
         设置在计算颜色转换时用作遮罩的通道:
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          没有
         </b>
         -使用整个图像区域。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          源 Alpha
         </b>
         -使用的 alpha 通道
         <b>
          源
         </b>
         剪辑作为面具。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          源倒阿尔法
         </b>
         -使用的倒阿尔法通道
         <b>
          源
         </b>
         剪辑作为面具。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          遮罩亮度
         </b>
         -使用的亮度
         <b>
          面具
         </b>
         作为遮罩输入。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          掩模倒置亮度
         </b>
         -使用倒置的亮度
         <b>
          面具
         </b>
         作为遮罩输入。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          面具阿尔法
         </b>
         -使用的 alpha 通道
         <b>
          面具
         </b>
         作为遮罩输入。
        </p>
        <p class="bulleted" data-mc-autonum="• ">
         <span class="autonumber">
          <span>
           •
          </span>
         </span>
         <b>
          面具倒阿尔法
         </b>
         -使用的倒阿尔法通道
         <b>
          面具
         </b>
         作为 mask.s 的输入
        </p>
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
  <div class="MCDropDown MCDropDown_Open dropDown">
   <span class="MCDropDownHead dropDownHead">
    <a class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage" href="javascript:void(0);">
     <img alt="Closed" class="MCDropDown_Image_Icon" data-mc-alt2="Open" height="13" src="../../../skins/default/stylesheets/Images/transparent.gif" width="16"/>
     <span class="Master_VariablesVideoContent">
      视频教程
     </span>
    </a>
   </span>
   <div class="MCDropDownBody dropDownBody">
    <div class="MCDropDown MCDropDown_Open dropDown">
     <span class="MCDropDownHead dropDownHead dropDownHeaddropDownHeadNoBold">
      <a class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage" href="javascript:void(0);">
       <img alt="Closed" class="MCDropDown_Image_Icon" data-mc-alt2="Open" height="13" src="../../../skins/default/stylesheets/Images/transparent.gif" width="16"/>
       Ocula 3.0-ColourMatcher
      </a>
     </span>
     <div class="MCDropDownBody dropDownBody">
      <iframe allowfullscreen="" frameborder="0" height="281" mozallowfullscreen="" src="https://player.vimeo.com/video/33671463?color=f9b41b;byline=0;portrait=0" webkitallowfullscreen="" width="500">
      </iframe>
      <p>
       <a href="https://vimeo.com/33671463" target="_blank">
        OCULA 3.0-颜色匹配器
       </a>
       从
       <a href="https://vimeo.com/thefoundry" target="_blank">
        铸造
       </a>
       上
       <a href="https://vimeo.com/" target="_blank">
        Vimeo
       </a>
       .
      </p>
      <div class="MCDropDown MCDropDown_Open dropDown">
       <span class="MCDropDownHead dropDownHead dropDownHeaddropDownHeadIndented">
        <a class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage" href="javascript:void(0);">
         <img alt="Closed" class="MCDropDown_Image_Icon" data-mc-alt2="Open" height="13" src="../../../skins/default/stylesheets/Images/transparent.gif" width="16"/>
         <span class="Master_VariablesTranscribedContent">
          转录
         </span>
        </a>
       </span>
       <div class="MCDropDownBody dropDownBody">
        <p>
         欢迎来到铸造厂的 Ocula。我叫乔恩，在本教程中，我们将看看在 Ocula 3.0 中设置和回顾 ColourMatcher 节点。我们将看看彩色校正这个镜头。如果我在左眼和右眼之间切换，在这里，你可以看到地板上的反射有一些很大的变化。我们希望将这些反射与图像相匹配，以缓解立体观看体验。在我的剧本中，我正在设置和回顾差异。我们正在渲染它以供使用，我在这里使用 Ocula 中的 ColourMatcher 节点进行颜色校正, 我们稍后会看看质量检查。
        </p>
        <p>
         所以，首先，让我们看看设置和审查。我已经在求解器节点中设置了分析键，并且正在使用 DisparityGenerator 节点中的默认参数。有一些关于如何设置求解器和 DisparityGenerator 节点的教程。这里我也有一个遮挡探测器节点，这在 Nuke 中增加了一个新的遮挡掩模通道。这定义了左右视图之间不匹配的像素，以及在视图之间被遮挡或显示的像素。当颜色匹配器将颜色从一个视图拉到另一个视图时，它将忽略那些被遮挡的像素。所以，如果我们看一下遮挡检测器，你可以调整遮挡的定义，我们稍后会看到如何做到这一点。在这里，您可以看到图像边界被定义为左视图和右视图之间的遮挡。我将渲染差异和遮挡，然后将其拉回用于颜色匹配节点。
        </p>
        <p>
         在 ColourMatcher 中，您可以定义左视图和右视图，是从左到右匹配，还是更新右视图以匹配左视图。有三种不同的方法来计算颜色:
         <b>
          基本
         </b>
         提升和增益，一个更复杂的
         <b>
          3D LUT
         </b>
         ,然后您可以导出以在 Ocula 或 Nuke 之外使用，还可以选择进行局部颜色校正 (
         <b>
          本地匹配
         </b>
         )。这与左右图像之间的小块相匹配，因此它将匹配视图之间的微妙变化，这是我们在这里看到的反射。您可以选择是否单独处理由遮挡检测器定义的遮挡区域，并且有一些参数需要调整。我们稍后将看到如何调整这些更新。也有一些
         <b>
          多尺度选项
         </b>
         对于块。您可以选择是否使用一个或多个块大小，可以设置要使用的最大块大小，还可以定义如何应用更新。这些选项有助于随着时间的推移稳定颜色更新。彩色匹配器也有一个
         <b>
          面具
         </b>
         输入。您可以选择如何使用基本和 3D LUT 方法定义蒙版，然后在蒙版区域计算更新并应用于整个图像。在
         <b>
          本地匹配
         </b>
         ,将为屏蔽区域计算更新，并将其应用于该屏蔽区域。所以，这是使用本地校正方法计算的更新; 你可以看到反射已经更新，所以它们在左右视图之间匹配。
        </p>
        <p>
         现在，让我们看看如何质量检查颜色校正。在这里，我正在重新计算校正板的差异。请注意，我必须从上游提取求解器信息。我可以在新的求解器节点中重新计算它。我使用的是与 Ocula 立体视图 gizmo 的差异。我已经把它设置为显示左右视图之间的棋盘键组合。如果我切换校正，我可以拿起 gizmo 上的汇合点，并四处移动，以检查图像不同部分左右的任何差异。如果我们看看原始镜头，你可以看到已经纠正的差异。所以，同样，如果我们四处移动，你可以在钥匙组合的左右视图中看到不同的颜色。质量检查的另一种方法是使用 NewView 节点将更正的视图拉到 “英雄” 视图上，然后您可以检查差异。我有 NewView 设置拉
         <b>
          左
         </b>
         看来，我们更新过的正确使用
         <b>
          内插位置
         </b>
         1。然后我可以做一个像素差，这样我们就可以一次检查整个图像上的错误。差异在这里，只有在边缘，这可能有一个亚像素偏移视差计算。如果我们看看原始的盘子，你可以看到颜色匹配节点修正的色差。
        </p>
        <p>
         让我们看看另一个镜头的颜色校正。这是左视图和右视图，有一个很大的颜色偏移，我们想在这里纠正。我已经键入了求解器，我们像以前一样计算视差和遮挡。如果我们看一下这些遮挡，这些像素在左右视图中被标记为不同的像素。现在有两种计算遮挡的方法，首先通过观察
         <b>
          深度遮挡
         </b>
         ,其中图像的一部分被另一部分遮住，另一部分通过查看图像内容的差异，使用视图之间颜色差异的阈值 (
         <b>
          颜色阈值
         </b>
         )。所以，我们可以关闭这些阈值，并将其调整到镜头。我要拉起,
         <b>
          深度遮挡
         </b>
         直到我们找出深度层之间的遮挡。我不想让这个变得太大太无聊。然后我可以和
         <b>
          颜色阈值
         </b>
         所以，同样，我可以开始把它拉起来，直到我们找出深度和场景之间变化的差异。我在这里倾向于非常保守; 你不想看到很多孤立的区域会在帧之间闪烁。我们希望它随着时间的推移保持稳定。这里还有一些选项可以细化遮挡区域，还有一些预设可以选择，根据左右视图之间的图像有多少不同。所以，我们在这里，看到了一个极端的差异，所以它要大得多。我为这张照片做的一件额外的事情是添加一个 roto 来屏蔽图像顶部的位，这在左右之间是不同的。所以，你可以用 Roto 或 RotoPaint 自由编辑遮挡面具。
        </p>
        <p>
         那么，让我们来看看配色的结果。这是的
         <b>
          基本
         </b>
         方法做提升和增益。您可以使用
         <b>
          3D LUT
         </b>
         方法，它基于像素匹配，基于左视图和右视图计算全局更新。所以，结果要好得多，但是它在水面上的反射仍然有一些变化。现在，我可以导出它，并在 Nuke 的 VectorField 节点中使用它，这样我就可以在没有 Ocula 的情况下应用 3D LUT，或者你可以在 Nuke 之外使用它。这是 ColourMatcher 结果，这是 VectorField 节点的结果，它们匹配。我们也可以做一个局部校正来匹配这个镜头中的水的反射。在这里，您可以看到结果: 左视图和右视图匹配。现在我们可以通过查看 NewView 中的色差来再次使用我们的 QC 技术。所以，这是局部颜色校正的差异，现在我们可以回去切换方法，比较这些差异。有很大的变化
         <b>
          基本
         </b>
         。它的更好
         <b>
          3D LUT
         </b>
         ,但是你可以看到水上的反射的差异。最后,
         <b>
          本地匹配
         </b>
         ,这给出了最好的结果。
        </p>
        <p>
         让我们再来看一个例子。在这张照片中，观点之间有一些极端的变化。当您从一个区域切换到另一个区域时，大区域不可见。在这里，你可以看到当我从左向右切换时，商店正面被遮住了。让我们用 NewView 回顾一下录像。我将颜色匹配左视图。所以，在这里，我想把右边拉向左边，然后把它和原来的左边比较。你可以看到它突出了店面。我们想用遮挡探测器探测这个区域。现在让我们来设置它。我要换来的
         <b>
          垫子
         </b>
         覆盖 (M)，你可以看到它拿起店面。但是有一些洞，还有一些孤立的区域，这些区域会闪烁，所以我们想移除它们并创建一个稳定的掩模。我要换来的
         <b>
          极端
         </b>
         设置。这将扩展遮罩并填充孔，以确保它们是稳定的。现在让我们像以前一样设置阈值。我们只是想挑选出这里的店面。我可以切换到设置
         <b>
          颜色阈值
         </b>
         接下来，我想确保掩模中没有孤立的补丁会闪烁，导致颜色更新闪烁。所以，这看起来不错。现在，我在这里做的一件额外的事情是添加一个旋转面具，只是为了确保遮挡被遮住。我本可以在遮挡检测器中关闭阈值，只使用旋转开关。
        </p>
        <p>
         现在，让我们看看左视图的颜色校正。所以，在这里，我们有基本的提升和增益。让我们切换到基于本地块的颜色匹配。现在你可以看到墙上有一条黄色的带子。这就是颜色匹配器补偿遮挡的地方。它查看遮罩外部的像素，并将颜色更新拉入遮罩内部。这里的问题是，它将更新从黑色区域拉入相邻的砖块。我只需要扩展
         <b>
          区域大小
         </b>
         ,它搜索颜色更新，以便从其他砖块中提取更新。你还可以限制其使用的相同颜色的减少
         <b>
          颜色西格玛
         </b>
         。现在，最后，你会注意到茶壶里有一些黑色的条纹。发生这种情况是因为这些块跨越了光明和黑暗区域。我需要使用一个较小的
         <b>
          块大小
         </b>
         ,所以更新覆盖了一个较小的区域。这看起来不错。您可以尝试调整多采样选项，特别是如果您在帧之间的校正更改中有任何问题; 多采样可以提高稳定性。现在，在我不满意的遮挡面具内部仍然有一些孤立的区域。我现在要做的是在这个区域切换到使用 3D LUT 结果。这是 3D LUT 校正，看起来不错。所以，我所做的是将遮挡掩模洗牌到 alpha 中，我将把它作为遮罩来挑选遮挡掩模内部的 3D LUT 校正, 和外面的地方修正。这是在原始结果和最终结果之间的切换，你可以看到它纠正了镜头中的一些阴影和反射。
        </p>
        <p>
         所以，这结束了这个关于彩色匹配器的教程。我们已经研究了渲染出用于颜色匹配的有差异的遮挡掩模。我们已经查看了本地颜色匹配和质量检查结果，特别是使用 NewView 在另一个视图上重建一个视图来查看颜色差异。然后我们看了一个更详细的例子，以及如何设置遮挡，如何用 roto 编辑它们，最后, 我们看了一个极端的遮挡例子，以及如何调整颜色匹配参数，以及在不同的颜色匹配结果之间切换。
        </p>
       </div>
      </div>
      <p>
       <!-- This version of the embed code is no longer supported. Learn more: https://vimeo.com/help/faq/embedding -->
      </p>
     </div>
    </div>
   </div>
  </div>
  <table style="width: 100%;border-bottom-style: solid;border-bottom-width: 1px;">
   <col/>
   <tbody>
    <tr>
     <td>
      <p>
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <div class="MCDropDown MCDropDown_Open dropDown dropDownMiniTOCmenu">
   <span class="MCDropDownHead dropDownHead">
    <a class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCDropDownHotSpot_MiniTOCmenu MCHotSpotImage" href="javascript:void(0);">
     <img alt="Closed" class="MCDropDown_Image_Icon" data-mc-alt2="Open" height="13" src="../../../skins/default/stylesheets/Images/transparent.gif" width="16"/>
     本节中的主题
    </a>
   </span>
   <div class="MCDropDownBody dropDownBody">
   </div>
  </div>
 </body>
 <script type="text/javascript">
  /* <![CDATA[ */
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-60569477-1', {'cookieDomain': 'none'});
	/* ]]> */
 </script>
 <script type="text/javascript">
  /* <![CDATA[ */
		$("document").ready(function ()
		{
		function postMe()
		{
		var cust = document.getElementById("search-field").value;
		console.log(cust);
		ga('send', 'event', "Nuke", "search", cust, 9);
		}
		var submitButton = $(".search-submit");
		submitButton.click(function() { postMe(); return true; } );
		var submit = $("input#search-field");
		submit.keypress(function(e) { if(e.keyCode==13) { postMe(); } return true; } );
		});
	/* ]]> */
 </script>
</html>