<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="Default.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Reference Guide|Ocula 3.0 Nodes">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>O_VerticalAligner</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../skins/default/stylesheets/components/styles.css" rel="stylesheet" />
        <link href="../../../skins/default/stylesheets/components/tablet.css" rel="stylesheet" />
        <link href="../../../skins/default/stylesheets/components/mobile.css" rel="stylesheet" />
        <link href="../../assets/stylesheets/master_tablestyle.css" rel="stylesheet" />
        <link href="../../assets/stylesheets/nuke_stylesheet.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
        <script src="../../assets/stylesheets/load.js">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop"><a href="../../../Default.html#reference_guide/ocula_nodes/o_verticalaligner.html">Open topic with navigation</a>
        </p>
        <script>/* <![CDATA[ */
			$(document).ready(function(){ 
			$('.dropDownMiniTOCmenu:not(:has([class*="MCMiniTocBox"]))').remove();
			});
		/* ]]> */</script>
        <div class="nocontent">
            <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="3" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">You are here: </span>
            </div>
        </div>
        <h1>O_VerticalAligner</h1>
        <p>The <a name="kanchor225"></a>O_VerticalAligner plug-in lets you warp views vertically so that their corresponding features align horizontally. The <span class="_Override" style="font-weight: bold;">Vertical Skew</span> and <span class="_Override" style="font-weight: bold;">Local Alignment</span> options allow you to warp the views while keeping the horizontal position of each pixel the same so that there is no change in convergence.</p>
        <div class="MCDropDown MCDropDown_Open dropDown"><span class="MCDropDownHead dropDownHead"><a href="javascript:void(0);" class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage"><img class="MCDropDown_Image_Icon" src="../../../Skins/Default/Stylesheets/Images/transparent.gif" height="13" width="16" alt="Closed" data-mc-alt2="Open" /><span class="Master_VariablesRGContent">Inputs and Controls</span></a></span>
            <div class="MCDropDownBody dropDownBody">
                <table cellpadding="0" cellspacing="0" style="border-spacing-x: 0;border-spacing-y: 0;border-collapse: collapse;border-color: black;caption-side: top;width: 100%;mc-table-style: url('../../assets/stylesheets/master_tablestyle.css');" class="TableStyle-Master_TableStyle" height="141px">
                    <col width="105px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <col width="120px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <col width="436px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <thead>
                        <tr style="height: 23px;background-color: #cac8c9;" class="TableStyle-Master_TableStyle-Head-Header1">
                            <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Connection Type</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Connection Name</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-HeadD-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Function</p>
                            </td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1" rowspan="2">
                                <p>Input</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Solver</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p> If you’re using the <b>Global Alignment</b> mode and the <b>Source</b> sequence doesn’t contain features that O_Solver is able to match well, you can use O_Solver on another sequence shot with the same camera setup. If you do so, connect O_Solver to this input.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body2">
                                <p>Source</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyA-Column1-Body2">
                                <p class="CellBody">A stereo pair of images.</p>
                                <p class="CellBody">In the <b>Global Alignment</b> mode, if you’re not using the <b>Solver</b> input, the images should be followed by an O_Solver node.</p>
                                <p class="CellBody">In the <b>Local Alignment</b> mode, you need an O_Solver node and a disparity field in this input. You can create a disparity field using O_DisparityGenerator.</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <table cellpadding="0" cellspacing="0" style="border-spacing-x: 0;border-spacing-y: 0;border-collapse: collapse;border-color: black;caption-side: top;width: 100%;mc-table-style: url('../../assets/stylesheets/master_tablestyle.css');" class="TableStyle-Master_TableStyle" height="603px">
                    <col width="100px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <col width="117px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <col width="108px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <col width="365px" class="TableStyle-Master_TableStyle-Column-Column1" />
                    <thead>
                        <tr style="height: 23px;background-color: #cac8c9;" class="TableStyle-Master_TableStyle-Head-Header1">
                            <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Control (UI)</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Knob (Scripting)</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-HeadE-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Default Value</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-HeadD-Column1-Header1" style="font-weight: bold;">
                                <p class="CellHeading">Function</p>
                            </td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="height: 15px;" class="TableStyle-Master_TableStyle-Body-Subheading" data-mc-pattern="6">
                            <td colspan="4" class="TableStyle-Master_TableStyle-BodyD-Column1-Subheading">
                                <p>O_VerticalAligner Tab</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Views to Use</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>viewPair</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Dependent on Source</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>Sets the two views  you want to align. These views will be mapped for the left and right eye.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Align</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>alignWhat</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Both Views</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p> Sets how to move the views to align the images:</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Both Views</b> - move both views half way.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Left to Right</b> - move the left view to line up with the right.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Right to Left</b> - move the right view to line up with the left.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Warp Mode</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>warpMode</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Global Alignment</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>Sets the mode to use for vertical alignment:</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Global Alignment</b> - applies a global image transform to align the feature matches generated by an upstream O_Solver node. You can use the <b>Global Method</b> menu to choose how this is done. With all methods, multiple O_VerticalAligner nodes concatenate with a single filter hit. You can also analyse to create Corner Pin and Camera information in all methods except <b>Vertical Skew</b>.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Local Alignment</b> - rebuilds the view(s) to remove vertical disparity calculated by an upstream O_DisparityGenerator. Use this mode to create a per-pixel correction if there are any local distortions in the mirror or lens and changes in alignment with depth.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Global Method</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>alignmentMethod</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Vertical Skew</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p>Selects the method you want to use to align the images when <b>Warp Mode</b> is set to <b>Global Alignment</b>:</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Vertical Skew</b> - align the features along the y axis using a skew. This does not move the features along the x axis.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Perspective Warp</b> - do a four-corner warp on the images to align them on the y axis. This may move the features slightly along the x axis.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Rotation</b> - align the features vertically by rotating the entire image around a point. The centre of the rotation is determined by the algorithm.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Scale</b> - align the features vertically by scaling the image.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Simple Shift</b> - align the features vertically by moving the entire image up or down.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Scale Rotate</b> - align the features vertically by simultaneously scaling and rotating the entire image around a point. The centre of the rotation is determined by the algorithm.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Camera Rotation</b> - align the features by first performing a 3D rotation of both cameras so that they have exactly the same orientation and a parallel viewing axis, and then reconverging the views to provide the original convergence. This method requires the camera geometry provided by an upstream O_Solver node. For best results, use the O_Solver <b>Camera</b> input to provide the information for the shooting cameras. If a <b>Camera</b> input is connected, the camera data is used per frame (rather than only taken from keyframes).</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>filter</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>filter</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Cubic</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>Select the filtering algorithm to use when remapping pixels from their original positions to new positions. This allows you to avoid problems with image quality, particularly in high contrast areas of the frame (where highly aliased, or jaggy, edges may appear if pixels are not filtered and retain their original values). </p>
                                <p class="note" data-mc-autonum="&lt;span style=&quot;color: Black;&quot; class=&quot;mcFormatColor&quot;&gt;NOTE:&lt;/span&gt; &#160;"><span class="autonumber"><span><span style="color: Black;" class="mcFormatColor">NOTE:</span> &#160;</span></span>This control is only available if you have set <b>Warp Mode</b> to <b>Global Alignment</b>.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Impulse</b> - remapped pixels carry their original values.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Cubic</b> - remapped pixels receive some smoothing.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Keys</b> - remapped pixels receive some smoothing, plus minor sharpening.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Simon</b> - remapped pixels receive some smoothing, plus medium sharpening.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Rifman</b> - remapped pixels receive some smoothing, plus significant sharpening.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Mitchell</b> - remapped pixels receive some smoothing, plus blurring to hide pixelation.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Parzen</b> - remapped pixels receive the greatest smoothing of all filters.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Notch</b> - remapped pixels receive flat smoothing (which tends to hide Moiré patterns).</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Analyse Sequence</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>analyse</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>N/A</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p>Click to analyse the sequence to create a corner pin or aligned camera output.</p>
                                <p>Use <b>Analyse Sequence</b> to create the output data in all global methods except <b>Vertical Skew</b> (the default). Then, use <b>Create Corner Pin</b>, <b>Create Camera</b>, or <b>Create Rig</b>.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Create Corner Pin</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>createPin</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>N/A</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>Click to create a corner pin representing the result of O_VerticalAligner once you have clicked <b>Analyse Sequence</b>. </p>
                                <p>You can use multiple O_VerticalAligner nodes to produce the desired alignment. Then, analyse on the final node to create a single corner pin to represent the concatenated transform. This works in all global methods except <b>Vertical Skew</b> (the default).</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Create Camera</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>createCamera</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>N/A</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p> If you have a pretracked Nuke stereo camera connected to the <b>Camera</b> input of the O_Solver up the tree and you have clicked <b>Analyse Sequence</b>, you can click this to create a vertically aligned camera from the analysis. </p>
                                <p>This gives you a single Camera node with split controls to hold the left and right view parameters. This works in all global methods except <b>Vertical Skew</b> (the default).</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Create Rig</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>createRig</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>N/A</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>If you have a pretracked Nuke stereo camera connected to the <b>Camera</b> input of the O_Solver up the tree and you have clicked <b>Analyse Sequence</b>, you can click this to create a vertically aligned camera rig from the analysis. </p>
                                <p>This gives you two Camera nodes and a JoinViews node that combines them. This works in all global methods except <b>Vertical Skew</b> (the default).</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Subheading" data-mc-pattern="6">
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Subheading" colspan="4">
                                <p>Output Tab</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2" colspan="4">
                                <p>Four Corner Pin</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Bottom Left xy</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>pinBL</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>0,0</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1" rowspan="4">
                                <p>These controls represent the 2D corner pin that can be applied to the input image to create the same result as O_VerticalAligner (in all global methods except <b>Vertical Skew</b>). </p>
                                <p>This allows you to do the analysis in Nuke, but take the matrix to a third-party application, such as Baselight, and align the image or camera there.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Bottom Left</b> - the coordinates of the bottom left corner pin calculated during the analysis pass.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Bottom Right</b> - the coordinates of the bottom right corner pin calculated during the analysis
pass.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Top Right</b> - the coordinates of the top right corner pin calculated during the analysis pass.</p>
                                <p class="bulleted" data-mc-autonum="• "><span class="autonumber"><span>• </span></span><b>Top Lef</b>t - the coordinates of the top left corner pin calculated during the analysis pass.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Bottom Right xy</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>pinBR</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>0,0</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Top Right xy</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>pinTR</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>0,0</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>Top left xy</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>pinTL</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>0,0</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>Transform Matrix</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>transformMatrix</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>N/A</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p>Provides the concatenated 2D transform for the vertical alignment. The matrix is filled when you click <b>Analyse Sequence</b> on the <b>O_VerticalAligner</b> tab. There is one matrix for each view in the source.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Subheading" data-mc-pattern="6">
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Subheading" colspan="4">
                                <p>Python Tab</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>before render</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>beforeRender</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>none</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p>These functions run prior to starting rendering in execute(). If they throw an exception, the render aborts.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>before each frame</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>beforeFrameRender</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">none</td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>These functions run prior to starting rendering of each individual frame. If they throw an exception, the render aborts.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>after each frame</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">
                                <p>afterFrameRender</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body1">none</td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body1">
                                <p>These functions run after each frame is finished rendering. They are not called if the render aborts. If they throw an exception, the render aborts.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body2">
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>after render</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">
                                <p>afterRender</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyE-Column1-Body2">none</td>
                            <td class="TableStyle-Master_TableStyle-BodyD-Column1-Body2">
                                <p>These functions run after rendering of all frames is finished. If they throw an error, the render aborts.</p>
                            </td>
                        </tr>
                        <tr class="TableStyle-Master_TableStyle-Body-Body1">
                            <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body1">
                                <p>render progress</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body1">
                                <p>renderProgress</p>
                            </td>
                            <td class="TableStyle-Master_TableStyle-BodyB-Column1-Body1">none</td>
                            <td class="TableStyle-Master_TableStyle-BodyA-Column1-Body1">
                                <p>These functions run during rendering to determine progress or failure.</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="MCDropDown MCDropDown_Open dropDown"><span class="MCDropDownHead dropDownHead"><a href="javascript:void(0);" class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage"><img class="MCDropDown_Image_Icon" src="../../../Skins/Default/Stylesheets/Images/transparent.gif" height="13" width="16" alt="Closed" data-mc-alt2="Open" /><span class="Master_VariablesVideoContent">Video Tutorials</span></a></span>
            <div class="MCDropDownBody dropDownBody">
                <div class="MCDropDown MCDropDown_Open dropDown"><span class="MCDropDownHead dropDownHead dropDownHeaddropDownHeadNoBold"><a href="javascript:void(0);" class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage"><img class="MCDropDown_Image_Icon" src="../../../Skins/Default/Stylesheets/Images/transparent.gif" height="13" width="16" alt="Closed" data-mc-alt2="Open" />Ocula 3.0 - VerticalAligner</a></span>
                    <div class="MCDropDownBody dropDownBody"><iframe src="https://player.vimeo.com/video/33669957?color=f9b41b;byline=0;portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
                        <p><a href="https://vimeo.com/33669957" target="_blank">OCULA 3.0 - VerticalAligner</a> from <a href="https://vimeo.com/thefoundry" target="_blank">Foundry</a> on <a href="https://vimeo.com/" target="_blank">Vimeo</a>.</p>
                        <div class="MCDropDown MCDropDown_Open dropDown"><span class="MCDropDownHead dropDownHead dropDownHeaddropDownHeadIndented"><a href="javascript:void(0);" class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCHotSpotImage"><img class="MCDropDown_Image_Icon" src="../../../Skins/Default/Stylesheets/Images/transparent.gif" height="13" width="16" alt="Closed" data-mc-alt2="Open" /><span class="Master_VariablesTranscribedContent">Transcription</span></a></span>
                            <div class="MCDropDownBody dropDownBody">
                                <p>Welcome to Ocula from Foundry, my name’s Jon. In this tutorial, we are looking at setting up and reviewing vertical alignment in Ocula 3.0. The Solver node calculates the stereo geometry of your input footage. We are going to use that information in the O_VerticalAligner node to correct the horizontal alignment of these plates. So we saw how to set up the Solver in the previous tutorial by defining some analysis keys on the timeline. On each analysis keyframe, the Solver calculates some feature matches between the left and right view. It uses the feature matching data to calculate the stereo geometry. It also uses it to calculate the alignment for the plates, and you can preview that directly inside the Solver to QC (quality-check) your feature matches. The O_VerticalAligner node applies that alignment data to the plates and interpolates it smoothly between the keys.</p>
                                <p>For this footage, I have combined several VerticalAligner nodes. If we take a look at the first one, you will see you can set the left and right view, you can choose whether to align both views or to align one view to a hero view, you can do a local per pixel warp which we will look at later, or a global alignment which acts like a corner pin. For the global alignment, you can choose different options for how it calculates the alignments for the plates, and you can choose the filter that’s used when it warps the images. So here you will see I have got four Aligners in a row. All of the global methods concatenate, so this will only generate a single filter hit. You are free to choose the most appropriate methods to align your plates. I generally have a <b>Simple Shift</b> upfront to align vertically first, I then apply a <b>Scale</b> to the plate to take out any focal length differences, and I then have a <b>Rotation</b> and this will take out any roll between the cameras. You can also choose to use <b>Camera Rotation</b> here, and this will take out roll and pitch between cameras. Finally, I then use a <b>Vertical Skew</b>, which you can use to take out any keystoning with a conversion camera rig. It’s important to remember though that skew can’t be represented by a corner pin. So if you do want to export a corner pin, which we will look at later, then use the <b>Perspective Warp</b> method as the final step.</p>
                                <p>Ok, let’s have a look at how the final alignment works. To QC alignment, you can use an Anaglyph node to overlay the left and right nodes and check for any vertical mismatches that remain in your plates. You can also use the StereoReviewGizmo that comes with Ocula. Here it’s set to show a <b>Difference</b> image. I am calculating the disparity for the aligned plates, and the gizmo has a ReConverge node inside. You can pick up the converge point and move it around to check for vertical mismatches in different parts of the image. So here it looks like there’s a difference on the lights in the background. You can correct this by going back and reviewing the alignment options you chose using the VerticalAligner nodes. Alternatively, what we're going to do here is add some user-defined matches in the analysis key in O_Solver. So this locks down the alignment exactly at those user-defined feature matches. I am going to add some on the lights in the background on both sides here, taking great care to make sure they are matched exactly in the same position. We can go back to our Anaglyph node and see how well the alignment now works. The lights now match up.</p>
                                <p>It’s important to remember that the alignment is weighted to ensure the user matches are horizontal now, so if you have any change in alignment with depth, you need to place those user matches at different depths. Now we have a way to QC the alignment and correct the analysis keys in O_Solver. You can see that the ghosting effect has now disappeared in that light in the background. We now need to check the alignment in between the keys to see how well it’s interpolated. There are a lot of frames to get through here, so a trick is to look at the disparity that’s being calculated for the aligned plates. I have got an Expression node that’s set up to look at the vertical component of disparity and check it against the threshold to see if there is any significant vertical discrepancy between the left and right view. It is worth noting here that I have increased the <b>Strength</b> in my DisparityGenerator to make sure I do pick up any mismatches in the alignment.</p>
                                <p>I have rendered that out and I can read it back in and play it back to see if there are any bad frames that I need to check first. So there’s a small discrepancy on this frame. If I switch back, you will see here, around frame 105 and 106, that some large discrepancies are being shown. So now I actually need to go back to Solver and add a new <b>Analysis Key</b> to re-calculate the alignment here - interpolating isn't good enough.</p>
                                <p>Now let’s look at the <b>Local Alignment</b> option. This does a per-pixel update based on the vertical component and disparity. I have got a DisparityGenerator and I am calculating the vertical discrepancy between left and right views. I am correcting that locally, so there’s no vertical offset left in the plates. So here I have simulated a local distortion left in the plate, for example, if there was a distortion in the mirror for the mirror rig. This is the input footage and I have distorted this region over here. It’s exaggerated, so you can see it more easily. I am going to do a global correction as we did before. Here’s the global result. This can’t correct the local distortion in the plates, so you can still see that the lights are still displaced, and if I switch to view the local correction afterwards, you can see this gets corrected. So if I switch between the two, you can see the correction is only being applied in a local region where the plate was distorted to begin with. So the local alignment can be used to correct distortions. You can also use it to take out any high-frequency jitter in the rig without having to key every frame in O_Solver. The important thing to remember though is to correct globally first, so that you are only taking out small differences with the local alignments. If you correct large vertical discrepancies with this method, it can distort the pixel aspect in your footage.</p>
                                <p>Finally, if you have a match-moved camera for your shot, you can pull that into O_Solver before setting the analysis key. The feature matches in stereo geometry will then be based on those input cameras. You can then use the <b>Camera Rotation</b> method in the VerticalAligner to correct the matched-moved cameras, so the plates are aligned horizontally. Here are the aligned plates. Also, in VerticalAligner you can analyse the whole sequence and create a corner pin if you want to export the alignment outside Nuke. If you have that match-moved camera on the input, you can also create an aligned rig to use with the correct plates. You can do this with all the global alignment methods, except <b>Vertical Skew</b>, which you can’t represent with a camera or a corner pin. So here I have analysed the shot and created an aligned rig. If I switch to 3D, here’s the original rig and here’s the aligned rig next to it. So you can see its been rotated to match the aligned plates.</p>
                                <p>That wraps up this tutorial. We have taken a look at how to use the O_VerticalAligner node to align stereo footage horizontally based on the analysis keys in the O_Solver node. We have looked at how to QC the alignment,  how to add user-defined matches to correct alignment at the keyframes in O_Solver, and you can use disparity for the aligned plates to review how well the alignment works when it’s interpolated between the keyframes. We have also looked at the <b>Local Alignment</b> option to correct small distortions, and you can use this to remove high-frequency jitter in our rig. And we have pulled in a match-moved rig to define the alignment of the plates. Finally, we saw how you can analyse a sequence to output an aligned camera rig for the plates or to create a corner pin to export outside Nuke.</p>
                            </div>
                        </div>
                        <p>
                            <!-- This version of the embed code is no longer supported. Learn more: https://vimeo.com/help/faq/embedding -->
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <table style="width: 100%;border-bottom-style: solid;border-bottom-width: 1px;">
            <col />
            <tbody>
                <tr>
                    <td>
                        <p>&#160;</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <div class="MCDropDown MCDropDown_Open dropDown dropDownMiniTOCmenu"><span class="MCDropDownHead dropDownHead"><a href="javascript:void(0);" class="MCDropDownHotSpot dropDownHotspot MCDropDownHotSpot_ MCDropDownHotSpot_MiniTOCmenu MCHotSpotImage"><img class="MCDropDown_Image_Icon" src="../../../Skins/Default/Stylesheets/Images/transparent.gif" height="13" width="16" alt="Closed" data-mc-alt2="Open" />Topics In This Section</a></span>
            <div class="MCDropDownBody dropDownBody">
            </div>
        </div>
    </body>
    <script type="text/javascript">/* <![CDATA[ */
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-60569477-1', {'cookieDomain': 'none'});
	/* ]]> */</script>
    <script type="text/javascript">/* <![CDATA[ */
		$("document").ready(function ()
		{
		function postMe()
		{
		var cust = document.getElementById("search-field").value;
		console.log(cust);
		ga('send', 'event', "Nuke", "search", cust, 9);
		}
		var submitButton = $(".search-submit");
		submitButton.click(function() { postMe(); return true; } );
		var submit = $("input#search-field");
		submit.keypress(function(e) { if(e.keyCode==13) { postMe(); } return true; } );
		});
	/* ]]> */</script>
</html>