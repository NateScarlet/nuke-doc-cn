define({"749":{i:0.000628501028004773,u:"../content/comp_environment/prmanrender/rendering_prmanrender.html",a:"Using PrmanRender  PrmanRender is a render node that works together with Pixar’s PhotoRealistic RenderMan® Pro Server  software to give you an even better quality render result. PrmanRender is an alternative to Nuke’s ScanlineRender with additional features for rendering 3D scenes. ",t:"Using PrmanRender "},"750":{i:0.000965657866423303,u:"../content/comp_environment/prmanrender/setting_up_renderman.html",a:"In order to use the PrmanRender node, you need to have Pixar’s PhotoRealistic RenderMan Pro Server  20, or earlier, installed and licensed on your machine (for brevity, we call it RenderMan from now on). To do this: If you\u0027re using Mac OS X 10.8 (Mountain Lion) or above, make sure X11 is installed ...",t:"Setting Up RenderMan Pro Server and PrmanRender"},"751":{i:0.000532879079206939,u:"../content/comp_environment/prmanrender/using_prmanrender.html",a:"The PrmanRender node can render nearly everything that you previously used ScanlineRender for, but with PrmanRender, you have control over aspects like shadows and reflections in your render result.  Connect the PrmanRender node to your Scene node, Camera node and any optional inputs, in the same ...",t:"Using The PrmanRender Node"},"752":{i:0.000321498003524325,u:"../content/comp_environment/prmanrender/adjusting_render_quality.html",a:"On the Sampling tab, you can adjust controls that affect your render quality. Adjust: ray trace max depth - to set the maximum depth of the view rays PrmanRender uses to trace your scene and make render calculations.  pixel samples - to set the number of samples to render per pixel. Having more ...",t:"Adjusting Render Quality"},"753":{i:0.00054797520414058,u:"../content/comp_environment/prmanrender/adjusting_shadows_dof.html",a:"On the PrmanRender tab, you can select if you want to render shadows, reflections, refractions and depth of field, or all of them into your result. All these effects are calculated using a retracing method that is based on drawing rays from the camera to the object. Check the box for: shadows - to ...",t:"Adjusting Shadows, Reflections, Refractions and Depth of Field"},"754":{i:0.000321498003524325,u:"../content/comp_environment/prmanrender/adjusting_motion_blur.html",a:"On the Sampling tab, you can adjust controls that affect motion blur. Adjust: motion blur samples - to set the number of samples to render per pixel when motion blurring. shutter - Enter the number of frames the shutter stays open when motion blurring. For example, a value of 0.5 would correspond to ...",t:"Adjusting Motion Blur Parameters"},"755":{i:0.000321498003524325,u:"../content/comp_environment/prmanrender/shader_parameters.html",a:"On the Shader tab you can select which channels are affected by motion vectors and output vectors.  Click motion vectors and select the type of vectors you’d like to render: off - no motion vector information is rendered. velocity - store the velocity of every single pixel in the motion vector ...",t:"Shader Parameters"},"756":{i:0.000321498003524325,u:"../content/comp_environment/prmanrender/rib_parameters.html",a:"With the RIB (RenderMan Interface Bytestream) parameters, you can choose to filter the information Nuke generates for RenderMan, set your arguments to it, and output your own RIB file. On the RIB tab: filter - check this to filter the information on your scene, generated by Nuke for RenderMan. In ...",t:"RIB Parameters"},"757":{i:0.000594774497125944,u:"../content/comp_environment/prmanrender/using_modifyrib.html",a:"You can use the ModifyRIB node to insert RIB (RenderMan Interface Bytestream) statements into your script to modify a RIB stream before it’s passed to the PrmanRender node. This can be useful in situations where you might want to adjust the shading on the surface of an object, replace it, or perform ...",t:"Using the ModifyRIB Node"},"758":{i:0.00058999854365703,u:"../content/comp_environment/prmanrender/using_reflection.html",a:"Reflection is the familiar physical phenomenon where an image of an object is cast back from a particular kind of surface, such as glass or water. Using PrmanRender node, you can replicate this effect in your render result of 3D objects, and using the Reflection node, you can adjust the controls for ...",t:"Using the Reflection Node"},"759":{i:0.000703237143965158,u:"../content/comp_environment/prmanrender/using_refraction.html",a:"Refraction is the familiar physical phenomenon of light traveling differently through different materials and thus reflecting differently off objects behind that material. For example, if you have a glass of water with a straw in it, the part of the straw that’s not in water appears to be in a ...",t:"Using the Refraction Node"},"760":{i:0.000649600589559791,u:"../content/furnacecore/deflicker2.html",a:"When working in film,  you sometimes have to deal with shots that have a luminance flicker. This chapter concentrates on removing flicker using F_DeFlicker2. Introduction F_Deflicker2 is used to remove flicker. It is particularly suitable for removing flicker that is localized and dependent on the ...",t:"Using F_DeFlicker2"},"761":{i:0.000321498003524325,u:"../content/furnacecore/deflicker2_quick_start.html",a:"To remove flicker from a sequence: Select Image \u003e Read to load the sequence you want to remove flicker from. Select FurnaceCore \u003e DeFlicker2 to apply DeFlicker2. View its output. If you’re not happy with the results, adjust the DeFlicker2 parameters. The available parameters are described below.",t:"Quick Start"},"762":{i:0.000321498003524325,u:"../content/furnacecore/deflicker2_parameters.html",a:"The parameters for F_DeFlicker2 are described below.  DeFlicker Amount - Use this to reduce flicker without removing it entirely; smaller values mean more will be left behind.  Block Size - To find where a certain pixel is located in the analysis range, the deflicker algorithm looks for a block of ...",t:"Parameters"},"763":{i:0.00133430733764364,u:"../content/furnacecore/regrain.html",a:"This chapter looks at adding grain to sequences using F_ReGrain. Introduction F_ReGrain is used to add  grain to a sequence. It has been designed to sample an area of grain from one image and then to generate unlimited amounts of this grain with exactly the same statistics as the original. This new ...",t:"Using F_ReGrain"},"764":{i:0.000321498003524325,u:"../content/furnacecore/regrain_quick_start.html",a:"Quick Start You can sample grain from an image and apply it to another (see  Adding Sampled Grain ) or select from a variety of pre-sampled, standard grain types (see  Using Pre-Sampled, Standard Grain Types ).",t:"Quick Start"},"765":{i:0.000458136250325134,u:"../content/furnacecore/adding_sampled_grain.html",a:"To add grain to a sequence, do the following: Select Image \u003e Read to load the sequence you want to add grain to. Then, load the image you want to sample grain from. Make sure you are working at full resolution and not proxy resolution. F_ReGrain will not work at proxy resolution. (See  Proxy ...",t:"Adding Sampled Grain"},"766":{i:0.000458136250325134,u:"../content/furnacecore/using_standard_grain_types.html",a:"Using Pre-Sampled, Standard Grain TypesIf you don’t have an image to sample grain from, you can also select from a variety of pre-sampled, standard grain types. Do the following: Select Image \u003e Read to load the sequence you want to add grain to. Make sure you are working at full resolution and not ...",t:"Using Pre-Sampled, Standard Grain Types"},"767":{i:0.000321498003524325,u:"../content/furnacecore/response.html",a:"In its default setting, F_ReGrain adds the same amount of grain over the whole image. However, the amount of grain on an image is normally a function of luminance. Various parameters in the Grain Response group allow you to adjust how the amount of grain added varies with luminance: Pressing ...",t:"Response"},"768":{i:0.000321498003524325,u:"../content/furnacecore/checking_result.html",a:"To test that the new grain is the same as the old grain, set Output to Grain Plate. This generates a sheet of grain with the same luminance level as the mean of the sample region. The sample region with the original grain is also displayed. It should be impossible to differentiate between the two ...",t:"Checking the Result"},"769":{i:0.00110033930156385,u:"../content/furnacecore/proxy_resolutions.html",a:"Grain manipulation at proxy resolution should be avoided as the results are unreliable. The grain selection area may be too small at proxy resolution to give a good result, and making this area larger may drag in unwanted detail from the image. If you try to use F_ReGrain at proxy resolution, we ...",t:"Proxy Resolutions"},"770":{i:0.000321498003524325,u:"../content/furnacecore/regrain_parameters.html",a:"The parameters for this plug-in are described below: Grain Type - Selects whether the grain is sampled from the Grain image (From Grain Clip) or from a set of standard stocks. Preset Stock - grain characteristics are sampled from a supplied film stock. 2K, 4K, aperture corrected and non aperture ...",t:"Parameters"},"771":{i:0.000321498003524325,u:"../content/furnacecore/regrain_color_space.html",a:"Some of the algorithms in the FurnaceCore tool set are sensitive to the color space of the source footage. If the footage is not in the expected color space, you may get poor results from some of the plug-ins. Like Nuke, FurnaceCore expects all footage to be in Linear space. Nuke converts all ...",t:"Color Space in FurnaceCore Plug-ins"},"772":{i:0.000649340445784842,u:"../content/furnacecore/wireremoval.html",a:" This chapter looks at the  removal of wires from images using F_WireRemoval. Introduction Many effects movies feature complicated stunts that require an actor to be suspended by wires for their safety. These wires need to be digitally removed. There are many ways of doing this, including painting ...",t:"Using F_WireRemoval "},"773":{i:0.000321498003524325,u:"../content/furnacecore/background.html",a:"Clean Plates The use of clean plates in wire removal is very common and gives good results in certain situations.  Consider a scene shot with an actor suspended from wires and then the same scene shot again without the actor. This second sequence is called the clean plate. The wires from the first ...",t:"Background"},"774":{i:0.000412590168058198,u:"../content/furnacecore/reconstruction_methods.html",a:"Our four reconstruction methods are: Spatial  Temporal With Static Scene  Temporal With Moving Scene Clean Plate The spatial method takes the background information from adjacent pixels in the current frame, and the clean plate method takes the information from a separate clean plate input. The ...",t:"Reconstruction Methods"},"775":{i:0.000321498003524325,u:"../content/furnacecore/tracker.html",a:"F_WireRemoval incorporates a tracker which can automatically track a moving wire through a clip. This tracker has its own control panel, which will float inside the NukeX viewer if you have checked Show On Screen Controls in the WireRemoval controls. Below is a screenshot that illustrates this.  You ...",t:"Tracker"},"776":{i:0.000321498003524325,u:"../content/furnacecore/wireremoval_quick_start.html",a:"To remove a wire from an image sequence, do the following:  Select Image \u003e Read to load the clip that needs a wire removed. Select FurnaceCore \u003e F_WireRemoval. Connect your image sequence to F_WireRemoval’s Source input. View the output from F_WireRemoval. Make sure Output is set to Source, and use ...",t:"Quick Start"},"777":{i:0.000412590168058198,u:"../content/furnacecore/positioning_wire_tool.html",a:"To position the on-screen wire tool, do the following: In the F_WireRemoval controls, set Output to Source. This way, you will be able to see the wire you’re trying to remove but won’t have to wait for F_WireRemoval to repair the wire every time you change wire tool’s position.  Choose the number of ...",t:"Positioning the On-Screen Wire Tool"},"778":{i:0.000321498003524325,u:"../content/furnacecore/tracking.html",a:"F_WireRemoval incorporates a tracker that tracks the region to be repaired through the image sequence.  To use the tracker, do the following: Drag the on-screen wire tool to position the repair region on top of the wire on one frame. This sets a user keyframe for the current frame, enabling ...",t:"Tracking"},"779":{i:0.000321498003524325,u:"../content/furnacecore/user_and_track_keyframes.html",a:"User keyframes are keyframes you set manually. When a user keyframe has been set on the current frame, this is indicated by a red key that appears on the on-screen wire tool. Track keyframes are keyframes set by F_WireRemoval’s tracker. User keyframes override track keyframes on the same frame. This ...",t:"User Keyframes and Track Keyframes"},"780":{i:0.000321498003524325,u:"../content/furnacecore/indicators_wire_tool.html",a:"Indicators on the On-Screen Wire Tool You may see the following indicators appear on the on-screen wire tool:  ",t:"Indicators on the On-Screen Wire Tool"},"781":{i:0.00123241964886306,u:"../content/furnacecore/tracker_controls.html",a:"Tracker Controls The following controls appear in the on-screen tracker panel that you can display in the Viewer by checking Show On Screen Controls in the WireRemoval properties. The corresponding controls are also available in the WireRemoval properties.",t:"Tracker Controls"},"782":{i:0.000321498003524325,u:"../content/furnacecore/wireremoval_parameters.html",a:" The parameters for this plug-in are described below. Tracker buttons - most of the on-screen tracker panel buttons also appear here. For more information, see  Tracker Controls . Type - this parameter controls the number of points on the on-screen wire tool. Choose the number of points needed to ...",t:"Parameters "},"783":{i:0.00142583475102968,u:"../content/furnacecore/global_motion_estimation.html",a:"FurnaceCore has three effects based on global motion estimation  (GME).  Introduction FurnaceCore effect based on global motion estimation  calculate a four-corner pin, which finds the best fit of one image onto another, and then apply that pin. These effects differ in how that corner pin is ...",t:"Global Motion Estimation"},"784":{i:0.000321498003524325,u:"../content/furnacecore/what_is_gme.html",a:"Global motion estimation (GME) is a technique that attempts to map one image onto another with a simple four-corner pin. This differs from local motion estimation (LME), which attempts to find where each individual pixel in the image is in the other image. GME is much cheaper to compute than LME, ...",t:"What is Global Motion Estimation?"},"785":{i:0.000321498003524325,u:"../content/furnacecore/analyzing_gme_effects.html",a:"The  Analyzing Global Motion Estimation Effects F_Align and F_Steadiness work in a similar way, which is distinct from the way F_RigRemoval works. These two effects calculate a four-corner pin for each frame and save it into the corner pin parameters. These pins are then used during the render to ...",t:"The Analyzing Global Motion Estimation Effects"},"786":{i:0.000321498003524325,u:"../content/furnacecore/gme_controls.html",a:"Controls The controls common to all GME plug-ins are described below. They are grouped into two sections:  Ones that determine how analysis is carried out. See  Parameters That Affect Analysis . Ones that control the rendering of the output. See  Parameters That Affect Rendering .",t:"Controls"},"787":{i:0.000458136250325134,u:"../content/furnacecore/parameters_analysis.html",a:"The following parameters affect the analysis of the four-corner pin. Analyse - This is a push button which triggers an analysis of the input clips and calculate a corner pin. Interrupting the analysis does not delete the corner pin keys that have already been calculated.  Render During Analysis - If ...",t:"Parameters That Affect Analysis"},"788":{i:0.000458136250325134,u:"../content/furnacecore/parameters_rendering.html",a:"These following parameters control how a GME effect renders the four-corner pin. Some of them are set during the analysis pass. Filtering - This controls the quality of the rendering. Low - uses nearest neighbor filtering. This gives low quality but is quick to render. Medium - uses a bilinear ...",t:"Parameters That Affect Rendering"},"789":{i:0.000321498003524325,u:"../content/furnacecore/widgets.html",a:"All the Analyzing GME effects have two on-screen widgets: one to provide feedback and one to set up the analysis region. Analysis Region Widget - This is a rectangle widget which you use to set the analysis region over the reference image. Four Corner Widget - This is a widget that shows the state ...",t:"Widgets"},"790":{i:0.000649600589559791,u:"../content/furnacecore/align.html",a:"This chapter l ooks at how to use F_Align to register (line up) two shots that are of the same scene, but have slightly different camera motion and foreground objects. This can be useful, for example, for doubling up the crowd size by lining up and comping together two shots of the same scene, or ...",t:"Using F_Align"},"791":{i:0.000321498003524325,u:"../content/furnacecore/align_quick_start.html",a:"Quick Start  This section gives a very brief outline of how to use the plug-in. It covers both analyzing using the Analyse button (see  Analyzing with the Analyse button ) and analyzing on the fly (see  Analyzing On The Fly ).",t:"Quick Start "},"792":{i:0.000458136250325134,u:"../content/furnacecore/analyzing_button.html",a:"To align two shots and store the results as keyframed parameters, do the following: Find two shots that are of the same scene, but have slightly different camera motion and foreground objects. Select Image \u003e Read to load both these shots.  Select FurnaceCore \u003e F_Align. Connect the shot you want to ...",t:"Analyzing with the Analyse button"},"793":{i:0.000458136250325134,u:"../content/furnacecore/analyzing_on_the_fly.html",a:"To align two shots and calculate the alignment on the fly, do the following: Find two shots that are of the same scene, but have slightly different camera motion and foreground objects. Select Image \u003e Read to load both these shots.  Select FurnaceCore \u003e F_Align.  Connect one of the shots to the ...",t:"Analyzing On The Fly"},"794":{i:0.000321498003524325,u:"../content/furnacecore/align_parameters.html",a:"The parameters for this plug-in are described below. Analyse - This is a push button which will trigger an analysis of the input clips and calculate a corner pin. Interrupting the analysis will not delete the corner pin keys that have already been calculated. Render During Analysis - If set, this ...",t:"Parameters"},"795":{i:0.000558334995842619,u:"../content/furnacecore/rigremoval.html",a:"This chapter looks at the removal of unwanted  objects (rigs) from image sequences without accurate rotoscoping or keying to produce a clean plate. Introduction In this context, we define a rig as a foreground element in a sequence that moves over a background element. The plug-in will only work ...",t:"Using F_RigRemoval"},"796":{i:0.000594774497125944,u:"../content/furnacecore/rigremoval_quick_start.html",a:" To remove an unwanted object from an image sequence, do the following: Select Image \u003e Read to load the sequence with an unwanted object. Select FurnaceCore \u003e F_RigRemoval and connect your image sequence to F_RigRemoval’s Src input. View the output of F_RigRemoval. On each frame, define the area ...",t:"Quick Start "},"797":{i:0.000321498003524325,u:"../content/furnacecore/occlusions.html",a:"The algorithm used in F_RigRemoval is unable to differentiate between multiple foreground objects. If there is another foreground object in the sequence that moves through the background region that is being used in the repair, this second foreground object will also be cut up and used, resulting in ...",t:"Occlusions"},"798":{i:0.000321498003524325,u:"../content/furnacecore/rigremoval_parameters.html",a:"The parameters for this plug-in are described below. Rig Region - Defines the area to repair. Box - repair the area inside a rectangular box, controlled by the box parameters below or the on-screen box.  Src Alpha - repair the region defined by the alpha of the source input.  Src Inverted Alpha - ...",t:"Parameters"},"799":{i:0.000649600589559791,u:"../content/furnacecore/steadiness.html",a:"This chapter looks at how to  stabilize a sho t using F_Steadiness. Introduction F_Steadiness uses Global Motion Estimation (GME) to calculate a four- corner pin, so that camera motion within a single shot can be smoothed out over a range of frames or removed by locking to a specific frame. ...",t:"Using F_Steadiness"},"800":{i:0.000321498003524325,u:"../content/furnacecore/steadiness_quick_start.html",a:"Quick Start  This section gives a very brief outline of how to use the plug-in. See: Smoothing Out Camera Motion  , and Locking To A Frame  .",t:"Quick Start "},"801":{i:0.000458136250325134,u:"../content/furnacecore/smoothing_camera_motion.html",a:" To keep the overall camera motion but to smooth out sharp bumps and kicks, do the following: Find a shot that has some camera shake in it and select Image \u003e Read to load it. Select FurnaceCore \u003e F_Steadiness to apply F_Steadiness, and view its output. You will see the following banner in the ...",t:"Smoothing Out Camera Motion "},"802":{i:0.000458136250325134,u:"../content/furnacecore/locking_frame.html",a:" To completely remove camera motion from a sequence, do the following: Find a shot that has camera shake but where all frames share scene information and select Image \u003e Read to load it. Select FurnaceCore \u003e F_Steadiness to apply F_Steadiness, and view its output. You will see the following banner in ...",t:"Locking To A Frame "},"803":{i:0.000321498003524325,u:"../content/furnacecore/steadiness_parameters.html",a:"The parameters for this plug-in are described below. Analyse - This is a push button which will trigger an analysis of the input clip and calculate a corner pin. Interrupting the analysis will not delete the corner pin keys that have already been calculated. Render During Analysis - If set, this ...",t:"Parameters"},"804":{i:0.000512962342758981,u:"../content/comp_environment/blinkscript/image_processing_blink.html",a:"The BlinkScript node runs Foundry\u0027s Blink framework enabling you to write your code once and run it on any supported device. This is achieved through code translation, in which  the Blink code is turned  into specific code for each target device.  Code is generated and compiled on-the-fly, allowing ...",t:"Using the BlinkScript Node"},"805":{i:0.000321498003524325,u:"../content/comp_environment/blinkscript/quickstart.html",a:"To get started with BlinkScript: Connect the BlinkScript node to your sequence or image. See  Connecting the BlinkScript Node  for more information. Edit the default InvertKernel, load an example kernel, or write your own from scratch. See  Loading, Editing, and Saving Kernels  for more information. ...",t:"Quick Start"},"806":{i:0.000376153302244648,u:"../content/comp_environment/blinkscript/connecting_blink.html",a:"Select Other \u003e BlinkScript to create a BlinkScript node in the Node Graph. Connect the src input to your sequence or image. BlinkScript supports as many inputs as you create in your kernel, but the default InvertKernel only has a src input. Connect a Viewer to the output of the BlinkScript node. The ...",t:"Connecting the BlinkScript Node"},"807":{i:0.000376153302244648,u:"../content/comp_environment/blinkscript/load_edit_save.html",a:"Loading, Editing, and Saving Kernels Kernel management is taken care of on the first tab of the BlinkScript properties panel. Double-click the BlinkScript node in the Node Graph to display its properties. Loading, editing, and saving kernels is only available if you have a NukeX license.",t:"Loading, Editing, and Saving Kernels"},"808":{i:0.000321498003524325,u:"../content/comp_environment/blinkscript/loading_kernels.html",a:"Loading Kernels Enter the file-path in the Kernel File field or click the folder icon to browse to the kernel\u0027s location.  BlinkScript kernels use the .rpp file extension. Click Load. The selected kernel is compiled and read into the Kernel Source field.",t:"Loading Kernels"},"809":{i:0.000481365081408763,u:"../content/comp_environment/blinkscript/editing_kernels.html",a:"You can edit existing kernels or write your own from scratch by clicking Clear and entering code in the Kernel Source field. Bear in mind that you won\u0027t see any results in the Viewer until you click Recompile. You can change how text in the Kernel Source appears using the controls in the Preferences ...",t:"Editing Kernels"},"810":{i:0.000321498003524325,u:"../content/comp_environment/blinkscript/saving_kernels.html",a:"Enter the file path in the Kernel File field or click the folder icon to browse to the intended location.  BlinkScript kernels use the .rpp file extension. Click Save. The selected kernel is saved to the specified location. There is no compile step during saving as the kernel is compiled when ...",t:"Saving Kernels"},"811":{i:0.000376153302244648,u:"../content/comp_environment/blinkscript/setting_parameters.html",a:"Some BlinkScript controls are used by all kernels. Rather than write these individually in each instance, the BlinkScript properties panel includes Kernel Parameters and Settings tabs, providing easy access to the standard kernel controls. The Kernel Parameters tab also contains any controls exposed ...",t:"Setting Kernel Parameters"},"812":{i:0.000321498003524325,u:"../content/comp_environment/blinkscript/cpu_gpu.html",a:"The read-only Local GPU field displays the graphics card installed locally, if there is one available. You can toggle the GPU on and off using the Use GPU if available control. If you have multiple GPUs available, select the required device using the Preferences \u003e Performance \u003e Hardware \u003e default ...",t:"GPU or CPU?"},"813":{i:0.000321498003524325,u:"../content/comp_environment/blinkscript/specify_output_format.html",a:"BlinkScript\u0027s output defaults to the union of all its inputs, but you can specify a different output format by enabling Specify output format and selecting the required ratio from the format dropdown. Enabling Specify output format also adds the format control to the kernel once it has been ...",t:"Specifying the Output Format"},"814":{i:0.000376153302244648,u:"../content/comp_environment/blinkscript/performance_settings.html",a:"The performance controls on the Settings tab are common to all Blink kernels and don\u0027t affect the output, but can improve the processing speed: Percentage of GPU memory to use - sets the upper limit on the amount of memory BlinkScript can allocate. Higher values than the default 50% can improve ...",t:"Changing Performance Settings"},"815":{i:0.000809296873730706,u:"../content/comp_environment/blinkscript/publishing.html",a:"When you\u0027re happy with your kernel, you can publish it for use elsewhere in the script or in an entirely separate Nuke script. Published kernels are wrapped in a Group node, so you can save them as gizmos if required.  Blink kernels can also be encoded using the built-in kernel protection. Protected ...",t:"Publishing and Protecting Your Kernels"},"816":{i:0.000321498003524325,u:"../content/comp_environment/blinkscript/limitations_issues.html",a:"RGBA Only Processing is currently limited to the RGBA channels only. To work with other channels, use a Shuffle node to shuffle them into RGBA before connecting to the BlinkScript node. GPU Complicated kernels can cause driver timeouts on the GPU if they take too long to execute. The lower the ...",t:"Limitations and Known Issues"},"817":{i:0.000951335027605139,u:"../content/reference_guide/preface/reference_guide.html",a:"About this Reference Guide This documentation is intended as a reference for all the parameters within each node in Nuke. It does not give you any instructions on using Nuke.  For details on installing and using Nuke, refer to  Installation and Licensing . Currently, some nodes only include a brief ...",t:"Reference Guide"},"818":{i:0.000321498003524325,u:"../content/reference_guide/image_nodes/image_nodes.html",a:"Image Nodes Image nodes deal with loading, viewing, and rendering image sequences as well as creating built-in Nuke elements, such as checkerboards and color wheels.",t:"Image Nodes"},"819":{i:0.000321498003524325,u:"../content/reference_guide/image_nodes/checkerboard.html",a:"CheckerBoard Generates a checkerboard image that you can use as a placeholder for a texture or background. If you enable proxy mode the board may not match the full resolution version, because the boxes are rounded to the nearest pixel. Inputs and Controls",t:"CheckerBoard"},"820":{i:0.000321498003524325,u:"../content/reference_guide/image_nodes/colorbars.html",a:"ColorBars Generates a Society of Motion Picture and Television Engineers (SMPTE) color bars test pattern, useful for color management. Inputs and Controls",t:"ColorBars"},"821":{i:0.000321498003524325,u:"../content/reference_guide/image_nodes/colorwheel.html",a:"ColorWheel Generates a color wheel image. Inputs and Controls",t:"ColorWheel"},"822":{i:0.000321498003524325,u:"../content/reference_guide/image_nodes/constant.html",a:"Constant Generates an image where every pixel is the same color. This includes pixels outside the image area as well as inside it. Inputs and Controls",t:"Constant"},});