define({"1118":{i:0.000387628042802646,u:"../content/reference_guide/other_nodes/audioread.html",a:"AudioRead You can use this node to read in an audio file and view it in the Curve Editor and Dope Sheet in order to line up keyframes of your composition with the waveform of the sound. You can then flipbook the audio with your footage to preview your comp with sound.  Inputs and Controls",t:"AudioRead"},"1119":{i:0.00055913269237093,u:"../content/reference_guide/other_nodes/backdrop.html",a:"This node visually groups nodes in the Node Graph. Inserting a Backdrop node creates a box behind the nodes. When you move the box, all the nodes that overlap the box are moved too. By inserting several Backdrop nodes, you can group the nodes in your node tree onto boxes of different colors and ...",t:"Backdrop"},"1120":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/blinkscript.html",a:"The BlinkScript node runs Foundry\u0027s Blink framework enabling us to write our code once and run it on any supported device. This is achieved through code translation, in which  the Blink code is turned into specific code for each target device.  Code is generated and compiled on-the-fly, allowing you ...",t:"BlinkScript"},"1121":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/burnin.html",a:"The BurnIn node allows you to add text to certain areas of your footage quickly, without relying on the Text node. Inputs and Controls Control (UI) Knob (Scripting) Default Value Function BurnIn Tab color burnIn_color 1 Sets the color of the burn-in text. opacity burnIn_opacity 1 Sets the opacity of ...",t:"BurnIn"},"1122":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/diskcache.html",a:"DiskCache caches to disk scanlines from its input as they are requested by its output. It does this at full 32-bit floating point. This allows Nuke to reference the cached data instead of constantly recalculating the output of the preceding nodes. By default, DiskCache caches the selected channels ...",t:"DiskCache"},"1123":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/dot.html",a:"Dot You can use the Dot node to make bends in the connecting arrows between other nodes. This can help you keep your script easy to read. The Dot node does not alter the input image in any way. You can also create this node by pressing . (period) on the Node Graph. Inputs and Controls",t:"Dot"},"1124":{i:0.00113917691388139,u:"../content/reference_guide/other_nodes/group.html",a:"You can use the Group node to nest multiple nodes inside a single node. The original nodes are replaced with the Group node. When you create a Group node, its internal structure is shown in a separate Node Graph that opens. You can also create this node by pressing Ctrl/Cmd+G on the Node Graph. See ...",t:"Group"},"1125":{i:0.00055913269237093,u:"../content/reference_guide/other_nodes/input.html",a:"Adds an input arrow to a  Group  node. This allows you to add multiple inputs to your Group or gizmo (for example a main input and a mask input). By default, the inputs are numbered, but if you want to name them, you can do so by renaming the Input nodes. Note that you should always connect the main ...",t:"Input"},"1126":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/noop.html",a:"NoOp passes the input image through unchanged. It does not alter the image in any way, but can be used as an interface for controlling other nodes. To do so, right-click on the NoOp control panel, select Manage User Knobs, and add the control you need (for example, a checkbox). Then, Ctrl+Cmd+drag ...",t:"NoOp"},"1127":{i:0.00055913269237093,u:"../content/reference_guide/other_nodes/output.html",a:"Adds an output arrow to a  Group  node. This is necessary if the node tree that forms the Group has several branches and thus several possible output nodes. It can also be useful if you accidentally delete an Output node from a Group. The output arrows are always unnamed. See also  Group  and  Input ...",t:"Output"},"1128":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/postagestamp.html",a:"You can add this node to your script to display a thumbnail render of the output at the current frame or a frame of your choice. This node does not alter the input image in anyway. By default, the postage stamp is always updated to match the current frame. To change this behavior, press Shift+S to ...",t:"PostageStamp"},"1129":{i:0.000805656116988816,u:"../content/reference_guide/other_nodes/precomp.html",a:"The Precomp node is like a  Group  node, but its content is stored in an independent .nk file. This allows you to save a subset of the node tree as a separate Nuke script, render the output of this saved script, and read the rendered output back into the main comp as a single image input. Precomp ...",t:"Precomp"},"1130":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/root.html",a:"The Project Settings in the Compositing environment are contained within the Root node, but the node itself is never visible in the Node Graph. When you start working on a script, you should first define the settings for it in the Project Settings. You can display the Project Settings by navigating ...",t:"Root"},"1131":{i:0.00055913269237093,u:"../content/reference_guide/other_nodes/stickynote.html",a:"StickyNote Lets you add notes to the Node Graph. The notes can be any text or HTML mark-up. Usually, they are made as annotations to the elements in the node tree. See also  Backdrop . Step-by-Step Guides Adding Notes to the Node Graph",t:"StickyNote"},"1132":{i:0.000321498003524325,u:"../content/reference_guide/other_nodes/all_plugins.html",a:"This menu contains all nodes available in Nuke, including any unsupported nodes (such as earlier versions of the currently supported nodes). Note that some of these nodes may be unstable or cause unexpected behavior. If you have any gizmos installed, they also appear in this menu.  To refresh the ...",t:"All plugins"},"1133":{i:0.000321498003524325,u:"../content/reference_guide/furnacecore_nodes/furnacecore_nodes_nukex.html",a:"FurnaceCore Nodes FurnaceCore nodes  contain the most popular Furnace plug-ins incorporated in NukeX and Nuke Studio.",t:"FurnaceCore Nodes"},"1134":{i:0.000321498003524325,u:"../content/reference_guide/furnacecore_nodes/f_align.html",a:"F_Align takes two sequences that were shot of the same scene and lines them up spatially. It uses Global Motion Estimation (GME) to calculate a four-corner pin so that each frame in one shot (the source input) will be aligned with the corresponding frame in a second shot (the reference input). The ...",t:"F_Align"},"1135":{i:0.000321498003524325,u:"../content/reference_guide/furnacecore_nodes/f_deflicker2.html",a:"F_Deflicker2 is used to remove flicker - particularly flicker that is localized and dependent on the geometry of the scene (that is, flicker that is not present across the whole of the image), such as that caused by an un-synchronized fluorescent light in a shot. F_DeFlicker2 looks at input frames ...",t:"F_DeFlicker2"},"1136":{i:0.00136461417927416,u:"../content/reference_guide/furnacecore_nodes/f_regrain.html",a:"F_ReGrain is used to add grain to a sequence. It is designed to sample an area of grain from one image and then to generate unlimited amounts of this grain with exactly the same statistics as the original. This new grain can then be applied to another image.  See also  Grain  and  ScannedGrain . ...",t:"F_ReGrain"},"1137":{i:0.000642381324250672,u:"../content/reference_guide/furnacecore_nodes/f_rigremoval.html",a:"F_RigRemoval eliminates unwanted objects, or rigs, from image sequences without the need for accurate rotoscoping or keying to produce a clean plate. The rig removal algorithm works by estimating the background motion between successive frames, ignoring the foreground object, and then using the ...",t:"F_RigRemoval"},"1138":{i:0.000321498003524325,u:"../content/reference_guide/furnacecore_nodes/f_steadiness.html",a:"F_Steadiness uses Global Motion Estimation (GME) to calculate a four-corner pin, so that camera motion within a single shot can be smoothed out over a range of frames or removed by locking to a specific frame. Inputs and Controls Control (UI) Knob (Scripting) Default Value Function F_Steadiness Tab ...",t:"F_Steadiness"},"1139":{i:0.000642381324250672,u:"../content/reference_guide/furnacecore_nodes/f_wireremoval.html",a:"F_WireRemoval is particularly good at removing wires over heavily motion blurred backgrounds or wires over smoke, dust, or clouds. It can be used to remove each wire in a sequence or to quickly create a clean plate which can then be tracked into place. F_WireRemoval also incorporates a tracker which ...",t:"F_WireRemoval"},"1140":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/ocula_nodes.html",a:"Ocula 3.0 Nodes Ocula nodes are only available if you have an Ocula license for Nuke.",t:"Ocula 3.0 Nodes"},"1141":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_colourmatcher.html",a:"The O_ColourMatcher plug-in lets you match the colours of one view with those of another. It has been specifically designed to deal with the subtle  colour differences that are sometimes present between stereo views. Inputs and Controls Control (UI) Knob (Scripting) Default Value Function ...",t:"O_ColourMatcher"},"1142":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_depthtodisparity.html",a:"Many Ocula plug-ins rely on disparity fields to produce their output. Usually, disparity fields are created using a combination of the O_Solver and O_DisparityGenerator nodes. However, if you have a CG scene with stereo camera information and z-depth map available, you can also use the ...",t:"O_DepthToDisparity"},"1143":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_disparitygenerator.html",a:"The O_DisparityGenerator plug-in is used to create disparity fields for stereo images. A  disparity field maps the location of a pixel in one view to the location of its corresponding pixel in the other view. It includes two sets of  disparity vectors: one maps the left view to the right, and the ...",t:"O_DisparityGenerator"},"1144":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_disparitytodepth.html",a:"The O_DisparityToDepth plug-in produces a z-depth map for each view of a stereo clip based on the clip’s disparity field and stereo camera setup. A z-depth map is an image that uses the brightness of each pixel to specify the distance between the 3D scene point and the virtual camera used to capture ...",t:"O_DisparityToDepth"},"1145":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_disparityviewer.html",a:"The O_DisparityViewer plug-in lets you visualise the  disparity  vectors in your node tree, display a histogram detailing positive and negative parallax, or overlay the Viewer with parallax violations. All three O_DisparityViewer modes are baked into your render if the node is enabled when you write ...",t:"O_DisparityViewer"},"1146":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_focusmatcher.html",a:"O_FocusMatcher attempts to correct subtle focus differences that are typically present between the left and right views of a stereo image. It does this by matching the focus distribution of one view to that of the other, based on the disparity vectors upstream. Inputs and Controls Control (UI) Knob ...",t:"O_FocusMatcher"},"1147":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_interaxialshifter.html",a:"The O_InteraxialShifter plug-in lets you reduce the  interaxial distance of stereo images; that is, the distance between the two cameras. Using this plug-in, you can generate two new views at specified positions between the original images. Inputs and Controls Control (UI) Knob (Scripting) Default ...",t:"O_InteraxialShifter"},"1148":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_newview.html",a:"Using the O_NewView plug-in, you can create a single view from a stereo pair of images. You can create this new view at any position between the original views. The new view replaces both of the existing views. Inputs and Controls Control (UI) Knob (Scripting) Default Value Function O_NewView Tab ...",t:"O_NewView"},"1149":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_occlusiondetector.html",a:"O_OcclusionDetector generates a mask for the occluded pixels in each view: that is, pixels visible in one view but not the other. Inputs and Controls Control (UI) Knob (Scripting) Default Value Function O_OcclusionDetector Tab Views to Use viewPair Dependent on source Sets the two views you want to ...",t:"O_OcclusionDetector"},"1150":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_retimer.html",a:"O_Retimer is designed to slow down or speed up stereo footage using upstream motion vectors generated by the O_VectorGenerator node. These motion vectors describe how each pixel moves from frame to frame. With accurate motion vectors, it is possible to generate an output image at any point in time ...",t:"O_Retimer"},"1151":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_solver.html",a:"The O_Solver plug-in defines the geometric relationship between the two views in the input images (that is, the camera relationship or solve). This is necessary if you want to use DisparityGenerator, VectorGenerator, or VerticalAligner down the tree. Inputs and Controls Control (UI) Knob (Scripting) ...",t:"O_Solver"},"1152":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_vectorgenerator.html",a:"O_VectorGenerator generates  motion vector fields for each view in a stereo image. A motion vector field maps the location of a pixel on one frame to the location of the corresponding pixel in a neighbouring frame. It has the same dimensions as the image, but contains an (x,y) offset per pixel. ...",t:"O_VectorGenerator"},"1153":{i:0.000321498003524325,u:"../content/reference_guide/ocula_nodes/o_verticalaligner.html",a:"The  O_VerticalAligner plug-in lets you warp views vertically so that their corresponding features align horizontally. The Vertical Skew and Local Alignment options allow you to warp the views while keeping the horizontal position of each pixel the same so that there is no change in convergence. ...",t:"O_VerticalAligner"},"1154":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/ocula_nodes.html",a:"Ocula 4.0 Nodes Ocula nodes are only available if you have an Ocula license for Nuke.",t:"Ocula 4.0 Nodes"},"1155":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_colourmatcher4_0.html",a:"The O_ColourMatcher node enables you match the colours of one view with those of another. It has been specifically designed to deal with the subtle  colour differences that are sometimes present between stereo views. Inputs and Controls Control (UI) Knob (Scripting) Default Value Function ...",t:"O_ColourMatcher"},"1156":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_depthtodisparity4_0.html",a:"Many Ocula nodes rely on disparity maps to produce their output. Usually, disparity maps are created using a combination of the O_Solver and O_DisparityGenerator nodes. However, if you have a CG scene with stereo camera information and z-depth map available, you can also use the O_DepthToDisparity ...",t:"O_DepthToDisparity"},"1157":{i:0.000868050990727563,u:"../content/reference_guide/ocula4_0/o_disparitygenerator4_0.html",a:"The O_DisparityGenerator node is used to create disparity maps for stereo images. A disparity map describes the location of a pixel in one view in relation to the location of its corresponding pixel in the other view. It includes two sets of disparity vectors: one maps the left view to the right, ...",t:"O_DisparityGenerator"},"1158":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_disparitytodepth4_0.html",a:"The O_DisparityToDepth node produces a z-depth map for each view of a stereo clip based on the clip’s disparity map and stereo camera setup. A z-depth map is an image that uses the brightness of each pixel to specify the distance between the 3D scene point and the virtual camera used to capture the ...",t:"O_DisparityToDepth"},"1159":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_disparityviewer4_0.html",a:"The O_DisparityViewer node lets you visualise the  disparity  vectors in your node tree, display a histogram detailing positive and negative parallax, or overlay the Viewer with parallax violations. All three O_DisparityViewer modes are baked into your render if the node is enabled when you write ...",t:"O_DisparityViewer"},"1160":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_focusmatcher4_0.html",a:"O_FocusMatcher is designed to correct subtle focus differences that are sometimes present between the left and right views of a stereo image. It does this by matching the focus distribution of one view to the other, based on the disparity vectors upstream. Inputs and Controls Control (UI) Knob ...",t:"O_FocusMatcher"},"1161":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_interaxialshifter4_0.html",a:"The O_InteraxialShifter node allows you to adjust the interaxial distance of stereo images. Interaxial distance is the distance between the left and right cameras. Using this O_InteraxialShifter node, you can generate two new views at specified positions between the left and right images. Inputs and ...",t:"O_InteraxialShifter"},"1162":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_multisample4_0.html",a:"The O_MultiSample node allows you to use a Sample input to sample a selected area for one of the following uses: Fill the whole image with a smooth interpolation of the data from the sample area. Any channels can be used including depth, colour, disparity, and so on. Fill the area defined in the ...",t:"O_MultiSample"},"1163":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_newview4_0.html",a:"Use the O_NewView node to reconstruct a view – either left or right – using the pixels from the other view. For example, you can choose to reconstruct the left view using the pixels from the right view. This can be useful if you want to manipulate one view (with a gizmo, node, or graphics editor for ...",t:"O_NewView"},"1164":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_occlusiondetector4_0.html",a:"O_OcclusionDetector generates a mask for the occluded pixels in each view: that is, pixels visible in one view but not the other. Inputs and Controls Control (UI) Knob (Scripting) Default Value Description O_OcclusionDetector Tab Local GPU gpuName N/A Displays the GPU used for rendering when Use GPU ...",t:"O_OcclusionDetector"},"1165":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_retimer4_0.html",a:"O_Retimer is designed to retime footage so that it plays back faster or in slow-motion. O_Retimer uses upstream motion vectors generated by an O_VectorGenerator node to retime the footage. These motion vectors describe how each pixel moves from frame to frame (see  O_VectorGenerator ). With accurate ...",t:"O_Retimer"},"1166":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_solver4_0.html",a:"The O_Solver node defines the geometric relationship between the two views in the input images (that is, the camera relationship or solve). This is necessary when aligning footage with O_VerticalAligner. It is also required to calculate aligned disparity vectors, when using the alignment control in  ...",t:"O_Solver"},"1167":{i:0.000594774497125944,u:"../content/reference_guide/ocula4_0/o_vectorgenerator4_0.html",a:"O_VectorGenerator generates  motion vector fields for each view in a stereo image. A motion vector field maps the location of a pixel on one frame to the location of the corresponding pixel in a neighbouring frame. It has the same dimensions as the image, but contains an (x,y) offset per pixel. ...",t:"O_VectorGenerator"},"1168":{i:0.000321498003524325,u:"../content/reference_guide/ocula4_0/o_verticalaligner4_0.html",a:"The  O_VerticalAligner node lets you warp views vertically so that their corresponding features align horizontally. The Vertical Skew and Local Alignment options allow you to warp the views while keeping the horizontal position of each pixel the same so that there is no change in convergence. Inputs ...",t:"O_VerticalAligner"},"1169":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/caravr_nodes.html",a:"CaraVR 1.0 Nodes CaraVR nodes are only available if you have a CaraVR license for Nuke.",t:"CaraVR 1.0 Nodes"},"1170":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_alphagenerator.html",a:"C_AlphaGenerator creates a rectangular or elliptical mask in the alpha channel. It\u0027s primarily used for manual stitching and is included in the Manual 2D and 3D Stitching toolsets included in C_CameraSolver\u0027s Export dropdown. See the CaraVR  Online Help  for more information on C_AlphaGenerator. ...",t:"C_AlphaGenerator"},"1171":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_bilateral.html",a:"C_Bilateral is a smoothing filter that operates by mixing nearby source pixels according to their spatial distance and color similarity. The filter is particularly good at preserving edges, though it can be computationally expensive. \t\tIt\u0027s similar to the standard Nuke Bilateral node, but with the ...",t:"C_Bilateral"},"1172":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_blender.html",a:"C_Blender is used as a Merge node to combine all images together when manually correcting a stitch. The C_Stitcher can output separate warped images, which can be corrected manually to remove vertical misalignment, edited to control the seam between different images, and then finally combined by ...",t:"C_Blender"},"1173":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_blur.html",a:"C_Blur allows you to apply blur to a latlong image and produce a sensible result across the entire frame, as if it were applied to a rectilinear image all around.  Adds blur to an image or matte using Box or Gaussian filter algorithms. The blur value is calculated for image pixels by examining their ...",t:"C_Blur"},"1174":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_camerasolver.html",a:"CaraVR\u0027s C_CameraSolver node creates an approximate camera geometry, relative to a nodal point or a sphere, for multi-camera rigs. This defines the location and orientation preview for each camera so that the images can be stitched by C_Stitcher for output. See the CaraVR  Online Help  for more ...",t:"C_CameraSolver"},"1175":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_colourmatcher.html",a:"C_ColourMatcher aims to produce a global gain-based color correction across all the views in a rig to balance out differences in exposure and white balance. It solves across all cameras to find the minimum required gain changes to ensure color similarity. C_ColourMatcher does not compensate for ...",t:"C_ColourMatcher"},"1176":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_disparitygenerator.html",a:"The C_DisparityGenerator node is used to create disparity maps for stereo images. A disparity map describes the location of a pixel in one view in relation to the location of its corresponding pixel in the other view. It includes two sets of disparity vectors: one maps the left view to the right, ...",t:"C_DisparityGenerator"},"1177":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_generatemap.html",a:"C_GenerateMap allows you to generate stitch_map and ppass_map channels. The stitch_map UV channels represent the absolute pixel positions of an image normalized between 0 and 1, whereas the ppass_map XYZ channels represent the normalized 3D coordinates of a latlong image ranging between -1 and 1. ...",t:"C_GenerateMap"},"1178":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_metadatatransform.html",a:"CaraVR metadata is initially created by C_CameraSolver, but C_MetaDataTransform can modify the stream, without adding filter hits on image quality, to perform certain operations, such as stabilizing a shot using C_Tracker. See the CaraVR  Online Help  for more information on C_MetaDataTransform. ...",t:"C_MetaDataTransform"},"1179":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_rayrender.html",a:"C_RayRender is based on the vanilla Nuke RayRender node, but it also includes a Camera tab to reconstruct stereographic VR sequences using slit scan techniques. Ray rendering is a 3D to 2D process, so there\u0027s some setup involved before you can use C_RayRender. When connected to a Scene node, the ...",t:"C_RayRender"},"1180":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_sphericaltransform.html",a:"C_SphericalTransform converts images between different projections, similar to the vanilla Nuke SphericalTransform node, but designed for 360 work and including Blink GPU acceleration. These view projections can be divided into two broad categories: full frame, such as Latlong, encompassing the ...",t:"C_SphericalTransform"},"1181":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_stmap.html",a:"The C_STMap node is a GPU accelerated version of Nuke\u0027s standard STMap node. The C_STMap node allows you to warp the src input according to the stitch or ppass attached to the map input. C_STMap accepts stitch_map and ppass_map channels in specified layers. The stitch_map UV channels represent the ...",t:"C_STMap"},"1182":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_stitcher.html",a:"C_Stitcher uses Ocula-style disparity vectors to line up matched features in the overlap areas between overlapping cameras and then blends the results to generate a spherical latlong. C_Stitcher requires a C_CameraSolver upstream to generate an image. See the CaraVR  Online Help  for more ...",t:"C_Stitcher"},"1183":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr/c_tracker.html",a:"CaraVR’s 2D Tracker allows you to extract animation data from the pan, tilt, and roll of a pattern. You can then apply the data directly to transform or match-move another element. Or you can invert the data values and apply them to the original element to stabilize the image. C_Tracker differs from ...",t:"C_Tracker"},"1184":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/caravr_nodes.html",a:"CaraVR 2.0 Nodes CaraVR nodes are only available if you have a CaraVR license for Nuke.",t:"CaraVR 2.0 Nodes"},"1185":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_alphagenerator2_0.html",a:"C_AlphaGenerator creates a rectangular or elliptical mask in the alpha channel. It\u0027s primarily used for manual stitching and is included in the Manual 2D and 3D Stitching toolsets included in C_CameraSolver\u0027s Export dropdown. See the CaraVR  Online Help  for more information on C_AlphaGenerator. ...",t:"C_AlphaGenerator"},"1186":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_bilateral2_0.html",a:"C_Bilateral is a smoothing filter that operates by mixing nearby source pixels according to their spatial distance and color similarity. The filter is particularly good at preserving edges, though it can be computationally expensive. \t\tIt\u0027s similar to the standard Nuke Bilateral node, but with the ...",t:"C_Bilateral"},"1187":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_blender2_0.html",a:"C_Blender is used as a Merge node to combine all images together when manually correcting a stitch. The C_Stitcher can output separate warped images, which can be corrected manually to remove vertical misalignment, edited to control the seam between different images, and then finally combined by ...",t:"C_Blender"},"1188":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_blur2_0.html",a:"C_Blur allows you to apply blur to a latlong image and produce a sensible result across the entire frame, as if it were applied to a rectilinear image all around.  Adds blur to an image or matte using Box or Gaussian filter algorithms. The blur value is calculated for image pixels by examining their ...",t:"C_Blur"},"1189":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_camerasolver2_0.html",a:"CaraVR\u0027s C_CameraSolver node creates an approximate camera geometry, relative to a nodal point or a sphere, for multi-camera rigs. This defines the location and orientation preview for each camera so that the images can be stitched by C_Stitcher for output. See the CaraVR  Online Help  for more ...",t:"C_CameraSolver"},"1190":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_colourmatcher2_0.html",a:"C_ColourMatcher aims to produce a global gain-based color correction across all the views in a rig to balance out differences in exposure and white balance. It solves across all cameras to find the minimum required gain changes to ensure color similarity. C_ColourMatcher does not compensate for ...",t:"C_ColourMatcher"},"1191":{i:0.000321498003524325,u:"../content/reference_guide/cara_vr2_0/c_disparitygenerator2_0.html",a:"The C_DisparityGenerator node is used to create disparity maps for stereo images. A disparity map describes the location of a pixel in one view in relation to the location of its corresponding pixel in the other view. It includes two sets of disparity vectors: one maps the left view to the right, ...",t:"C_DisparityGenerator"},});